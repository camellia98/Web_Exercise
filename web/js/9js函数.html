<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 函数（函数就是封装了一些可以被重复执行调用的代码块，目的：就是让大量代码重复使用）
1.函数使用（1.声明函数，2调用函数） 
1）声明函数
 function（函数） 函数名(一般动词加get)（）{
            函数体
        }
         sayHi();
    <script>
        // function 声明函数的关键字，小写，函数是做某件事情，函数名一般是动词，函数不调用自己不执行
       function sayHi() {
            console.log('hello');
       }
//  2）函数调用 函数名（）;  
        sayHi();
    </script>
函数封装（打包）就是把一个或多个功能通过函数的方式封装起来，对外只提供一个简单地函数接口
用函数求1~100之间的和
<script>
    // 在函数里面用循环
    function getSum(){
    var sum = 0;
    for(var i = 1;i <= 100;i++){
        sum += i;
    }
    console.log(sum);
    }
    // 必须调用函数
    getSum();
</script>
2，函数参数（函数参数可以有也可以没有，个数不限）（形参（默认值是undefined，是接受实参，可以当做不用声明的变量）和实参）(多个参数用逗号隔开)
function（函数） 函数名(一般动词加get)（形参1，形参2....）{//形参是形式上的参数
            函数体
        }
         sayHi(实参1，实参2...);实参是实际的参数
        
        <script>
            function cook(aru){//形参是接受实参
                console.log(aru);
            }
            cook('酸辣土豆丝');
        </script>
利用函数求任意两个数的和
        <script>
            function getSum(num1,num2){
                console.log(num1 + num2);
            }
            getSum(1,4);
        </script>
利用函数求任意两个数的之间的和
        <script>
            var sum = 0;
            function getSum(start,end){
                for(var i = start; i<= end;i++){
                    sum += i;
                }
                console.log(sum);
            }getSum(2,3)
        </script>
3，形参和实参的匹配问题
<script>
    function getSum(num1,num2){
        console.log(num1 + num2);
    }
    // 实参和形参的个数一致，则正常输出结果
    getSum(1,4);
    // 实参的个数多于形参，只会按照形参的个数来得出结果
    getSum(1,4,3);
     // 实参的个数小于形参，多于的形参的定义为undefined 最终结果为NaN
    getSum(1,);
</script>
4.函数的返回值return(只能返回一个值，如果多个值只会最后一个值为准)
1）我们函数只是实现某种功能，最终结果需要返回给函数的调用者函数名（）通过return 实现的
2）只要函数遇到return就把后面的结果 返回给函数的调用者 函数名（）= return 后面的结果
    function 函数名{
        return 需要返回的结果
    }
   函数名（）；//调用者
   <script>
        function getResult(){
            return 666;
        }
        getResult();//getResult() = 666
        console.log(getResult());
   </script>
求任意两个数之和
<script>
    function getSum(num1,num2){
        return num1+num2;
    }
    console.log(getSum(1,3));
</script>
利用函数求两个数的最大值
<script>
    function getMax(num1,num2){
       return num1 > num2 ? num1 : num2;//三元表达式
      
    }console.log(getMax(1,5));
</script>
<script>
    function getMax(arr){
    var max = arr[0];
    for(var i = 1;i < arr.length;i++){
        if(arr[i] > max){
            max = arr[i];
        }
    }
    return max;
}
// 两种输出方式
// console.log(getMax([5,2,99,101,67,77]));
// 在实际开发里面，我们经常用一个变量来接受，函数的返回结果，使用更简单
var re = getMax([5,2,99,101,67,77]);
console.log(re);
</script>
3）return 终止函数
    <script>
        function getSim(num1,num2){
            return num1 +num2;//return 后面的代码不会被执行
            alert('HH');
        }
        console.log(getSim(3,1));
    </script>
4）拓展(如果想在return多个值可以用数组)
<script>
    function getResult(num1,num2){
        return[num1 + num2,num1-num2,num1*num2,num1/num2];
    }
    var e = getResult(1,2);//返回数组
    for(var i = 0;i < e.length;i++ ){//数组遍历必须循环输出
    console.log(e[i]);
    }
</script>
5）函数如果没有return，则返回undefined
6）拓展break，continue，return的区别
break是结束当前循环体
continue跳出本次循环，继续执行下次循环
return不仅可以退出循环，还能够返回return后面的值。同时可以结束当前函数体内的代码
5.arguments（只有函数才有，而且每个函数都内置好了）(展示形式是一种伪数组)（里面存储了所有传递过来的实参）
伪数组（具有数组的length属性；按照数组索引的方式存储；他没有真正数组的一些方法，如pop（）push（））
<script>
    function fn(){
        for(var i = 0;i < arguments.length;i++){//整体输出也可以用遍历
            console.log(arguments[i]);
        }
    }
    fn(1,2,3);
</script>
利用函数求任意个数的最大值-->
    <script>
        function getMax(){
        var max = arguments[0];
           for(var i = 1; i < arguments.length;i++){
            if(arguments[i] > max){
                max = arguments[i];
            }
           }
           return max;
        }
        console.log(getMax(1,2,3));
        console.log(getMax(3,6,7,8));
    </script>


</head>

<body>
    
</body>
</html>